# 第2章. Java 内存区域与内存溢出异常

## 2.2 运行时数据区域

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501120954765.png" alt="image-20220501120954765" style="zoom:33%;" />

### 2.2.1 程序计数器

是一块较小的内存空间，由线程独享，可以看做是当前线程执行的字节码的行号指示器。

JVM 的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现，任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此为了线程切换后能恢复到正常的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

没有内存溢出的概念。

### 2.2.2 Java 虚拟机栈

线程私有，它的生命周期与线程相同，描述的是 Java 方法的执行的线程内存模型。

每个方法执行时，JVM 都会同步创建一个栈帧(stack frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种 JVM 基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 `returnAddress` 类型（指向一条字节码指令的地址）。

这些变量类型在局部变量表中的存储空间以局部变量槽（Slot）表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。
局部变量表的内存空间在编译期间完成分配，当进入一个方法时，这个方法在栈帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。
局部变量表一个槽占用 32b，局部变量的第一个槽总是 this 指针。

### 2.2.3 本地方法栈

与虚拟机栈发挥的作用十分相似，区别只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

它和 Java 虚拟机栈都有可能抛出 `StackOverflowError` 异常。

### 2.2.4 Java 堆

Java 堆是虚拟机管理的内存中最大的一块，是被所有**线程共享**的一块内存区域。该内存区域的唯一目的就是存放对象实例，Java 中的几乎所有的对象实例都是在这里分配内存。随着 Java 技术的进步，日后可能出现值类型的支持，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，**栈上分配、标量替换**优化手段已经导致一些微妙的变化悄然发生，所以说Java 对象都在堆上分配也不是那么绝对了。

Java 堆是**垃圾收集器管理**的内存区域，从内存回收的角度来看，现代垃圾回收器大部分都是基于分代收集理论设计，因此 Java 堆中经常会出现 "新生代"、"老年代"、"永久代"、"Eden 空间"、"From Survivor 空间"、"To Survivor 空间" 等名词。

从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（TLAB，Thread Local Allocation Buffer），以提升对象分配时的效率。

可以通过 `-Xmx` 和 `-Xms` 设定调节虚拟机大小。

### 2.2.5 方法区

是各个**线程共享**的内存区域，用于存储已被 JVM 加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

在 JDK8 以前，Java 程序员习惯将方法区称呼为 "永久代"，或者将两者混为一谈，本质上这两者不等价，当时的 `HotSpot` 设计团队选择把收集器的分代设计扩展至方法区，或者说用永久代来实现方法区而已，**这样使 `HotSpot` 的垃圾收集器能像管理堆一样管理方法区**。
但是对于其他虚拟机实现，是不存在永久代概念的，原则上**方法区的实现属于虚拟机细节**

> 这句话意思是方法区属于 JVM 规范，但是永久代不属于 JVM 规范，JVM 规范没有要求有永久代，这只是 `HotSpot` 为了方便管理方法区而设计的，其他虚拟机实现并没有永久代。
>
> 而实际上用永久代实现方法区不是一个好主意：这种设计导致 Java 应用更容易遇到内存溢出问题（永久代有 `-XX:MaxPermSize` 限制，不设置也有默认大小），而且有极少数方法（例如 `String:intern()`）会因永久代原因导致不同虚拟机实现有不同表现。
>
> JDK6 时，`HotSpot` 开发团队准备放弃永久代，逐步改用**本地内存**来实现方法区的计划；到了 JDK7 将原本放在永久代的字符串常量池、静态变量等移出到堆内存；到了 JDK8 终于彻底废除永久代，用元空间实现。

![image-20220501153247694](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501153247694.png)

**元空间的好处**：

- 减少报OOM的可能：**元空间与永久代类似，本质区别是元空间并不占用虚拟机内存了，而是使用本地内存**，由于本地内存一般是比较大的，所以方法区就没有那么容易报OOM。
- 提高JVM性能：元空间的**垃圾回收很少**，一定程度上减少了GC扫描及压缩的时间。
- 类及相关的元数据的生命周期与类加载器的一致；
- 每个加载器有专门的存储空间。

### 2.2.6 运行时常量池

是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用。这部分内容在类加载后存放到方法区的运行时常量池中。

Java 语言不要求常量只有在编译器才能产生，运行期间也可以将新的常量放入池中，这种特性被用的多的就是 String 类的 intern() 方法

> intern: 先去查看 **字符串常量池** 是否有该字符串，如果有，则返回字符串常量池中的**引用**；如果没有，则首先将其放入字符串常量池，再返回引用。
>
> 不同点： 如果是 JDK1.7，当字符串常量池中找不到对应的字符串时，不会将字符串拷贝到字符串常量池，而只是在字符串常量池生成一个对该字符串的引用。而 JDK1.6 会拷贝字符串至字符串常量池。

JDK 1.6 的字符串常量池在方法区， JDK1.7 在堆空间。

![image-20220501155848792](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501155848792.png)

### 2.2.7 直接内存

并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。但是这部分也被频繁使用，而且也可能导致 OOM 异常出现。

JDK1.4 中新加入 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 IO 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

本机直接内存的分配不会受到 java 对大小的限制，但是既然是内存，会受到本机总内存大小，以及处理器寻址空间的限制。

## 2.3 `HotSpot` 虚拟机探秘

深入探讨 `HotSpot` 在 Java 堆中对象分配、布局和访问的全过程。

### 2.3.1 对象的创建

当 JVM 遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号运用，并去检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，那么首先类加载。

**选择内存空间**：

类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存在类加载后就可以确定了，为对象分配空间相当于把一块确定的大小内存块从 Java 堆中划分出来。假设 Java 堆内存是**绝对规整**的，使用过的内存放在一边，空闲内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞**。
如果内存不规整，已经使用的和空闲内存互相交错，虚拟机就必须维护一个**空闲列表**，**记录哪些内存块可用**，分配时从空闲内存中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

而决定内存空间是否规整则又是由垃圾回收器选择什么垃圾回收算法决定。
例如 CMS 选择使用**标记清除**算法，则需要空闲列表；而 Serial、`ParNew` 等使用**标记压缩**算法的垃圾回收器，则使用指针碰撞算法。

**线程安全保证**：

对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针指向的位置在并发情况下是不安全的，如果多个线程使用同一块内存空间分配空间肯定会造成很严重的并发安全问题。解决这个问题有两个可选方案：

- **对分配内存空间的动作进行同步处理**，实际上虚拟机实现是采用 CAS 配上失败重试的方法保证更新操作的原子性。
- **将内存分配的动作划分在不同的空间进行**，每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区才需要同步锁定，虚拟机是否使用 TLAB 可以通过 `-XX:+/-UseTLAB` 参数来设定

**对对象的必要设置**：

例如这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的 GC 分代年龄等信息。

这些信息存放在对象的**对象头**中，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**<init>() 方法执行**：

上面工作完成后，从虚拟机的角度来看一个新对象产生了，但是从 Java 程序角度来看对象创建才刚开始：构造方法。即 Class 文件的 `<init>()` 方法还没有执行，所有字段都是默认的零值，对象需要的其他资源和状态信息没有按照预定的意图构造好。

### 2.3.2 对象的内存布局

对象在堆中存储布局可以划分为三个部分：**对象头、实例数据和对齐填充**

**==对象头==**包括两类信息：

- **用于存储对象自身的运行时数据**。例如哈希值、GC 分代手机年龄、锁状态标记、线程持有的锁、偏向线程 ID、偏向时间戳等。
  官方称之为 Mark Word。

  Mark Word 被设计成一个**动态定义**的数据结构，以便在极小的空间（32 位机器中 32 bit，64 位机器中 64 bit）内存储尽量多的数据，根据对象的状态复用自己的存储空间。

  例如 32 位虚拟机中，如对象未被同步锁锁定的状态下，25 bit 存储对象哈希值，4 bit 存储对象分代年龄，2 bit 存储锁标志位， 1bit 固定为 0，在其他状态（轻量级锁、重量级锁、GC 标记、可偏向）下对象存储内容如下：

  ![image-20220501180458049](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501180458049.png)

- **类型指针，即对象指向它的类型元数据的指针**。JVM 通过这个指针来确定该对象是哪个类的实例。不是所有的虚拟机都必须在对象数据上保留类型指针，**查找对象的元数据信息不一定要经过对象本身**。

  此外如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象大小，但是如果数组长度不确定，也无法推断数组的大小。

**==实例数据==部分是对象真正存储的有效信息**：

我们在代码中定义的各种类型的字段，无论从父类继承还是子类定义的字段都必须记录下来，这部分的存储顺序会受到虚拟机分配策略参数`-XX:FieldAllocationStyle`和字段在 Java 源码中定义顺序影响。

**==对齐填充==仅仅起着占位符的作用**：

`HotSpot` 要求对象起始地址必须是 8 byte 的整数倍，任何对象的大小都必须是 8 byte 的整数倍，因此如果对象头数据和实例数据部分加起来不是 8 byte 整数倍，那就需要对齐填充来补全。

### 2.3.3 对象的访问定位

创建对象是为了使用对象， Java 程序会通过**栈上**的 reference 数据来操作堆上的具体对象，对象访问方式主要有**使用句柄和直接指针**两种：

- 如果使用**句柄**访问，Java 堆中会划分一块内存作为句柄池， reference 中存储的就是对象的句柄地址，句柄中包含了对象实例数据和具体数据（对象字段信息和类字段信息）各自具体的地址信息，结构如下图：

  <img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501181943099.png" alt="image-20220501181943099" style="zoom: 50%;" />

- 使用**直接指针**访问，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，**reference 中存储的直接就是对象地址**，如果访问对象本身，就**不需要多一次间接访问的开销**。

  <img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220501182326808.png" alt="image-20220501182326808" style="zoom:50%;" />

优缺点：

- **句柄**好处是当对象被移动时只改变句柄中的实例数据指针，而 reference 本身不需要被修改。
- **直接指针**好处是速度快，节省了一次指针定位的开销。

`HotSpot` 主要使用直接指针来实现对象实例访问。

# 第3章. 垃圾收集器与内存分配策略

## 3.2 对象死了没有

### 3.2.1 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效，计数器值减一，计数器值为0的对象就是不可能再被使用的。

优点是实现简单，判定效率高。

缺点是无法解决循环引用问题。

### 3.2.2 可达性分析算法

Java 用的就是可达性分析算法。

基本思路就是通过一系列称为 `GC Roots` 的根对象作为起始点集合，从这些节点开始，根据引用关系向下搜索，**搜索过程走的路径称为引用链**，如果某个对象到 `GC Roots` 没有任何引用链相连，或者说 `GC Roots` 到这个对象不可达，证明此对象不再可以被使用，那么这个对象就是垃圾。

java 中，可能作为 `GC Roots` 的包括以下几种：

- 虚拟机栈中引用的对象。比如参数、局部变量、临时变量。
- 方法区中类静态属性引用的对象。
- 方法区中常量属性引用的对象。
- 本地方法栈中引用的对象。
- JVM 内部引用，例如 Class 对象。
- 被同步锁（synchronized 关键字）持有的对象。

### 3.2.3 引用

JDK1.2 后，新增了一些类型的引用，对引用的概念进行扩充，将引用分为**强引用、软引用、弱引用、虚引用**。

- **强引用**：最传统的引用，例如 `Object o = new Object();` 这里的 o 就是强引用。
  无论任何情况下，只要强引用关系还存在， 被引用的对象就不会被回收。
- **软引用**：用来描述一些还有用，但非必要的对象。只要被软引用关联的对象，系统将要 OOM 时，会将这些对象回收。
  如果这次回收还没有足够内存，才会抛出 OOM。`SoftRefrence` 类来实现软引用。
- **弱引用**：描述一些非必要对象，强度比软引用弱，只能生存到下一次 GC 为止。当 GC 开始工作时，都会回收掉只被弱引用关联的对象。`WeakRefrence` 类来实现。
- **虚引用**：最弱的一种引用，一个对象是否有虚引用，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象实例。
  为一个对象设置虚引用的唯一目的是为了能在这个对象被回收时收到一个系统通知。`PhantomReference` 类实现。

### 3.2.4 对象生存还是死亡

**可达性判定中不可达的对象不一定是非死不可，它们暂时处于缓刑阶段**。

要宣告一个对象死亡，至少要经历两次标记过程：

- 如果对象进行可达性分析判定不可达，它会被第一次标记。

- 随后进行一次筛选，筛选条件是**该对象是否有必要执行 `finalize()` 方法**。
  如果对象没有重写 `finalize()` 方法，或者 `finalize()` 方法被虚拟机调用，则认为没有必要执行。
  如果没有必要执行 `finalize()` 方法，直接回收。
  如果有必要，如下：

  > 该对象会被放置在一个名为 `F-Queue` 的队列中，稍后由一条由 JVM 创建的低优先级 `Finalizer` 线程去执行它们的 `finalize()` 方法。
  >
  > 注意：这里的执行不是说真的要执行到你结束，可能 `finalize()` 方法还没有执行结束，就对这个对象进行二次标记了。
  >
  > 如果这个对象在 `finalize()` 方法中就完成了成功拯救自己——重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出 "即将回收" 的集合。
  >
  > 如果这个对象还没有逃脱，那就二次标记，就一定回收了。

一次对象自我拯救代码：

```java
public class TestFinalize {
    public static TestFinalize SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("我还活着");
    }

    @Override
    protected void finalize() throws Throwable{
        System.out.println("finalize");
        // 重新关联
        TestFinalize.SAVE_HOOK = this;
    }

    public static void main(String[] args) {
        SAVE_HOOK = new TestFinalize();

        SAVE_HOOK = null;
        System.gc();
        try {
            Thread.sleep(500L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (SAVE_HOOK == null) {
            System.out.println("对象死亡");
        } else {
            SAVE_HOOK.isAlive();
        }

        // 第二次 gc 时 finalize 方法已经调用了，虚拟机不会再调用 finalize 方法。
        SAVE_HOOK = null;
        System.gc();
        try {
            Thread.sleep(500L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (SAVE_HOOK == null) {
            System.out.println("对象死亡");
        } else {
            SAVE_HOOK.isAlive();
        }
    }
}
```

`finalize()` 方法最好不要用， `finalize()` 能做的，用 try-finally 也能做。

### 3.2.5 回收方法区

回收方法区不是 JVM 规范的硬性规定，例如 JDK11 使其的 ZGC 收集器就不支持类卸载

方法区的GC 主要回收两部分内容：**废弃的常量和不再使用的类**。

- 回收**废弃常量**：和回收 Java 堆中对象非常类似：

  > 例如一个字符串 "java" 已经进入常量池，但是当前系统没有任何一个字符串对象的值是 java。如果这时发生内存回收，而且垃圾收集器判断有必要，这个 java 常量就会被清理出常量池，常量池中的其他类、方法、字段的符号引用也与此类似

- 回收**不再使用的类**：判定条件略为苛刻：

  - 该类所有实例被回收。
  - 加载该类的类加载器被回收。
  - 该类对应的 Class 对象没有任何地方被引用。

  满足上述三个条件才允许回收。注意这里仅仅是允许，没有真的回收，至于是否回收，`HotSpot` 虚拟机提供了 `-Xnoclassgc` 参数控制。

  在大量使用反射、动态代理、`CGLib` 等字节码框架这类频繁自定义类加载器的场景中，通常都需要 JVM 具备类卸载能力，保证不会对方法区造成过大的压力。

## 3.3 垃圾收集算法

### 3.3.1 分代收集理论

- 弱分代假说：绝大多数对象都是朝生夕死的。
- 强分代假说：熬过越多次 GC 的对象就越难以消亡。

这两个分代假说奠定了多款常用的 GC 收集器的一致的设计原则：**收集器应该将 Java 堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域中存储**。

在分代收集理论的基础上，设计者至少将 Java 堆划分为**新生代**和**老年代**两个区域。

- **新生代** 中每次垃圾收集都有大量对象被回收，每次回收存活后的少量对象逐步晋升到老年代中存放。

假如现在要进行一次局限于新生代区域内的收集，但新生代中的对象是完全可能被老年代的对象引用的，为了找出该区域的存活对象，不得不扫描一遍老年代。反之也一样。为了解决这个问题，需要对分代收集理论添加第三条法则：

- 跨带引用假说：跨带引用相对于同代引用来说仅占极少数。

这可能是根据前面两条结论的推论：存在相互引用引用的两个对象，应该倾向于同时生存或者同时死亡。

基于这个假说，我们就不用为了少量的跨带引用去扫描整个老年代，也不用浪费空间记录每一个对象是否存在以及存在哪些跨带引用。
只用在**新生代上建立一个全局数据结构：记忆集**，这个结构将老年代划分为多个小块，标识老年代的那一块存在跨带引用。
此后发生 Minor GC 时只有包含了跨代引用的小块内存中的对象才会被加入到 `GC Roots` 进行扫描。

这种方法会增加一些运行时的开销，但是是值得的。

GC 的统一定义：

- 部分收集（partial GC）：目标不是完整的 Java 堆的垃圾收集，分为：
  - 新生代收集（Minor GC）：目标只是新生代的垃圾收集。
  - 老年代收集（Major GC）：目标只是老年代的垃圾收集。目前只有 CMS 才有单独收集老年代的行为。
  - 混合收集（Mixed GC）：目标是收集**整个新生代和部分老年代**的收集。目前只有 G1 收集器才会有这种行为。
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

### 3.3.2 标记清除算法

算法分为"标记"和"清除"两个阶段：

- 首先标记出所有需要回收的对象。
- 标记完成后，统一回收所有被标记的对象。

优点：

- 实现简单。

缺点：

- 效率不稳定，如果堆中有大量对象需要回收，标记和清除这两个操作耗时。
- 内存碎片问题，会产生大量不连续的内存碎片，可能导致大对象找不到分配的地方不得不提前触发 GC。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220502220021801.png" alt="image-20220502220021801" style="zoom:50%;" />

### 3.3.3 标记复制算法

将可用内存按容量划分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一部分，再把已经使用过的内存空间一次清理掉。

如果多数对象都是存活的，这种算法会产生大量内存空间复制开销；
如果多数对象都是垃圾的，这种算法复制的就是少量内存空间。

`HotSpot` 虚拟机的新生代收集器实现：

> 将新生代分成一块较大的Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。GC 时，将 Eden 和 Survivor 存活的对象，一次性复制到另一块 Survivor 空间上，然后清理 Eden 和已用的 Survivor。
>
> 默认 Eden 和 Survivor 大小比例是 8:1，每次新生代可用内存空间为整个新生代容量的 90%。
>
> 但是问题是如果回收后有多于 10% 的对象存活怎么办呢？
>
> 这就依赖其他内存区域进行分配担保，这里的担保人就是老年代，如果剩余内存过多，多出的内存直接分配到老年代。

### 3.3.4 标记整理算法

和标记清除算法的区别就是：清除过后，会对内存空间进行一次整理操作。将所有存活对象向内存空间一端移动，然后清理边界以外的内存。

是否移动回收后的存活对象是一项优缺点并存的风险决策：

- 如果移动存活对象，这对老年代这种有大量存活对象的区域是一种极为负重的操作，而且这种操作必须全程暂停用户线程应用进行。
  这种停顿又称为 STW（Stop The World）

- 如果不移动存活对象，弥散于堆中的存活对象导致空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来剞劂。

从垃圾收集的停顿时间来看，不移动对象停顿时间更短，从整个程序的吞吐量来看，移动对象更划算。

`HotSpot` 中关注吞吐量的 Parallel Scavenge 收集器是基于标记整理算法的，而关注延迟的 CMS 收集器则是基于标记清除算法的。

另外，还有一种中庸式的解决方案：虚拟机多数采用清除算法，直到碎片化程度已经大到影响对象分配，在采用整理算法。基与清除算法的 CMS 就是采用这种方案。

## 3.4 `HotSpot` 算法实现细节

### 3.4.1 根节点枚举

之前介绍过可能是 GC Roots 的对象可能是常量，方法区中的对象等，但是现代 Java 应用十分庞大，光是方法区的大小可能就有数百上千 MB，所以必须制定一个高效的高效的根节点枚举算法。

迄今为止，所有收集器在根节点枚举时都是必须 STW 的，现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终必须在一个能保障一致性的快照中才可以进行。 CMS、G1、ZGC 等收集器，枚举根节点时也是需要停顿的。

目前主流 JVM 都是使用的准确式垃圾收集，当用户线程停顿时，不需要一个不漏检查所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着对象引用。`HotSpot` 使用 `OopMap` 数据结构来实现，类加载完成后 `HotSpot` 就可以把对象内什么偏移量上是什么类型的数据计算出来，即时编译也会把记录栈和寄存器中哪些位置是引用。

这样收集器就可以直接得到这些信息， 不需要一个不漏从 GC Roots 开始查找。

### 3.4.2 安全点

如果 `HotSpot` 为每个指令都生成 `OopMap` 那么空间成本就十分高昂，因此只有在安全点时，`HotSpot` 才会生成 `OopMap`。

- 安全点：以是否具有让程序长时间执行的特征为标准选取安全点。只有在安全点，用户代码才能暂停运行。

关于安全点，另一点需要考虑如何在垃圾收集时让所有线程都跑到最近的安全点然后停顿。有两种方案选择：

- 抢先式中断：不需要线程的执行代码主动配合，GC 时，系统首先中断所有用户线程，如果发现有的用户线程不在安全点，则恢复这条线程，让它一会再重新中断，直到运行到安全点。现在几乎没有虚拟机采用抢先式中断来暂停线程相应 GC 事件。
- 主动式中断：当 GC 需要中断线程时，不直接对线程操作，仅仅简单设置一个标志位，每个线程执行时会不断轮询这个标志，发现为真就在自己最近的安全点上挂起。

### 3.4.3 安全区域

当线程不执行时（没有分配处理器，睡眠或者阻塞），这时线程无法响应虚拟机的中断请求，不能再到安全点中断挂起自己，对于这种情况，就必须引入安全区域来解决。

> 安全区域：
>
> 在某一段代码片段中，引用关系不会发生变化，这个区域中任意地方开始 GC 都是安全的。可以看做拉伸的安全点。

用户线程执行到安全区域时，会标识自己已经进入安全区域，这样虚拟机要发起 GC 就不用去管那些声明自己在安全区域内的线程了。当线程离开安全区域时，会检查虚拟机是否完成根节点枚举，如果完成了线程继续执行，否则等待。

### 3.4.4 记忆集与卡表

为了解决对象跨代引用带来的问题，垃圾回收器在新生代中建立名为**记忆集**的数据结构，避免把整个老年代都加进 GC Roots 扫描范围。

实际上不只是新生代、老年代有跨带引用，只要设计部分区域收集，如G1、ZGC都会面临相同问题。

- 记忆集是一种用于记录从非收集区域向收集区域的指针集合的抽象数据结构。

  ```java
  class RemeberedSet {
      Object[] set[Object_InterGenerational_Reference_Size];
  }
  ```

  这种是记录全部含有跨带引用对象的实现方案，维护成本高昂，可以选择不同的记录精度：

  - 字长精度：精确到机器字长。
  - 对象精度：精确到对象。
  - 卡精度：精确到一块内存区域。

  第三种 **卡精度** 是用一种称为 **卡表** 的方式去实现记忆集，这是最常用的记忆集实现形式，卡表是记忆集的一种具体实现，定义了记忆集的记录精度、与堆内存的映射关系等。

- 卡表最简单的形式可以是一个字节数组，`HotSpot` 也是这样实现的

  ```c
  CARD_TABLE [this address >> 9] = 0;
  ```

  字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块成为**卡页**。如果卡表标识内存区域的起始地址是 0x0000 的话，卡表的0、1、2号元素，分别对应地址范围：0x0000-0x01FF、0x0200-0x03FF、0x0400-0x05FF 的卡页内存块。

  一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象存在跨带指针，就将卡表的数组元素的值标识为1，成这个元素变脏。没有则标识为0，GC 时只要筛选出卡表中脏的元素，就知道哪些卡页中包含跨带指针，将其加入 GC Roots 扫描即可。

### 3.4.5 写屏障

卡表是怎样维护的呢？

当其他分代区域中对象引用本区域（发生 GC 的区域）对象时，对应的卡表元素就变脏，变脏时间点原则上应该发生在引用类型字段复制的那一刻，那如何第一时间更新卡表呢？

如果是执行字节码，好处理，虚拟机负责每条字节码的执行。如果编译执行场景呢？经过编译后代码就是纯粹的指令流，必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作中。

`HotSpot` 是通过写屏障维护卡表状态（这里的写屏障不同于并发的内存屏障也就是volatile可见性原理）。

- 写屏障可以看成是虚拟机层面对 "引用类型字段赋值" 这个动作的 AOP 切面，引用对象赋值时会产生一个环形通知，供程序执行额外的动作，前后都在写屏障的覆盖范围内。

  引用写屏障后， JVM 会为所有赋值操作生成对应的指令，一旦收集器在写屏障中增加了更新卡表操作，只要对引用更新，就会产生额外的开销，不过这个开销不大。

  除了开销，卡表在高并发下还存在 "**伪共享**问题"。

  > 伪共享是并发底层细节需要考虑的问题，现代 CPU 的缓存系统中是以缓存行为单位存储，多线程修改互相独立变量是如果这些变量刚好共享一个缓存行就会彼此影响，而导致性能降低。

	一种简答的解决方案是不采用无条件的写屏障，首先检查卡表标记，只有卡表不脏时才标记为为脏。
	
### 3.4.6 并发的可达性分析

之前提过可达性分析需要在 STW 时才能安全进行，这就要冻结所有用户线程。
根节点枚举 GC Roots 相比整个 Java 堆中全部对象是极少数，在各种优化技巧下根节点枚举代价已经较小了。
可从 GC Roots 继续遍历对象，这个步骤的停顿时间就与 Java 堆容量成正比例关系。

想降低用户线程停顿，就先明白为什么必须在一个一致性快照才能进行对象图遍历。引入三色标记概念：

- **白色**：对象没有被 GC 收集器访问过。可达性分析开始时，所有对象都是白色的，分析阶段结束如果还是白色的，说明不可达。
- **黑色**：对象已经被垃圾收集器访问，且对象的所有引用都扫描了。黑色对象表示已经扫描过，是安全存活的，如果其他对象引用指向黑色对象，不用重新扫描，黑色对象不可能直接指向某个白色对象。
- **灰色**：对象已经被垃圾收集器访问过，但这个对象至少存在一个引用没有被扫描过。

如果收集器和用户线程并发工作，可能出现两种结果：

- 原本消亡的对象标记为存活。
- 存活的对象标记为消亡，这是无法忍受的。

当且仅当以下两个条件满足时，会产生对象消失问题：

- 插入一条或多条从黑色对象到白色对象的新引用。
- 删除了全部从灰色对象到白色对象的直接或间接引用。

为了解决并发扫描的对象消失问题，产生两种解决方案：

- **增量更新**：（解决第一点）黑色对象一旦新插入对白色对象的引用，变回灰色对象。
- **原始快照**：（解决第二点）无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。

## 3.5 经典垃圾收集器

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503165644622.png" alt="image-20220503165644622" style="zoom:50%;" />

大致关系图

### 3.5.1 Serial / Serial Old 收集器

这个收集器是一个单线程工作的收集器，收集垃圾时，它只会使用一条线程收集。它在 GC 时，必须暂停其他所有工作线程，直到它收集结束。

![image-20220503221218227](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503221218227.png)

这种垃圾收集器适合应用于单核处理器场景。

### 3.5.2 `ParNew` 收集器

实质上是 Serial 收集器的多线程并行版本，除了同时使用多线程进行垃圾收集之外，其他的行为包括 Serial 收集器可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都和 Serial 相同。

![image-20220503221602193](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503221602193.png)

`ParNew` 除了支持多线程并行收集，其他与 Serial 没什么区别，目前只有它能与 CMS 共协同工作。

- 并行：多条垃圾收集器线程共同工作。
- 并发：垃圾收集器线程和用户线程之间共同运行。

### 3.5.3 Parallel Scavenge 收集器

是一款新生代收集器，基于标记-复制算法实现，能够并行收集的多线程收集器，其诸多特性表面上看和 `ParNew` 十分相似。

Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程停顿时间，而 Parallel Scavenge 目标是达到一个可控的吞吐量。

```
吞吐量 = 运行用户代码时间 / 总运行时间
```

高吞吐量可以最高效利用处理器资源，尽快完成程序运算，主要适合于后台运算而不需要太多交互的任务。

Parallel Scavenge 收集器提供 `-XX:MaxGCPauseMillis` 参数控制最大垃圾收集停顿时间，`-XX:GCTimeRatio` 参数设置吞吐量大小，是一个大于 0 小于 100 的整数。

### 3.5.4 Serial Old 收集器

是 Serial 收集器的老年代版本，使用标记整理算法。

可以作为 CMS 后备方案使用。

![image-20220503221218227](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503221218227.png)

### 3.5.5 Parallel Old 收集器

是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记整理算法实现。

它可以和 Parallel Scavenge 混合使用。

在注重吞吐量或者处理器资源比较稀缺场景，都可以优先考虑 `Parallel Scavenge` 和 `Parallel Old` 收集器组合。

![image-20220503221602193](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503221602193.png)

### 3.5.6 CMS 收集器

获取最短回收停顿时间为目标的收集器。希望系统停顿时间最短，为用户带来良好的交互体验。

CMS 收集器基于标记清除算法实现，整体过程分为四步：

1. **初始标记**
2. **并发标记**
3. **重新标记**
4. **并发清除**

其中 **初始标记、重新标记** 这两个步骤需要 STW。

初始标记仅仅是标记一下 GC Roots 能直接关联的对象，速度很快。

并发标记就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，耗时长，但不需要中断用户线程。

重新标记是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记时间长。

并发清除，清理删除掉标记阶段已死亡的对象，不需要移动存活对象，可以和用户线程并发执行。

![image-20220503225903215](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220503225903215.png)

CMS 是一款优秀的收集器，并发收集、低停顿，但也有**缺点**：

- **对处理器资源非常敏感**。并发阶段虽然不会导致用户线程停顿，但是因为占用部分线程导致 APP 变慢，降低总吞吐量。

  CMS 默认启动的回收线程数：`(CPU + 3) / 4`。如果 CPU 数 >= 4，并发回收时只占用不大于 25% 的 CPU 资源，并且会随着 CPU 核心数增加而下降。但当 CPU 数小于 4 个，CMS 对用户程序的影响可能就很大。

  为了缓解这种情况，虚拟机提供一种称为 "增量式并发收集器" 的 CMS 收集器变种，工作流程和以前单核处理器 计算机 OS 抢占式多任务来模拟多喝并行多任务思想一样，并发标记、清除时让收集器线程、用户线程交替运行，减少 GC 线程独占资源时间。

- **无法处理浮动垃圾**：CMS 并发标记 并发清除阶段用户线程还在运行，会产生新的垃圾， CMS 无法再当次收集中处理它们，只好留待下一次 GC 时清理这些垃圾，这些垃圾就叫浮动垃圾。并且这段时间还要留内存给用户，因为用户线程还会新建对象。JDK 启动阈值在 JDK6 时是 92%，但是会面临风险：CMS 运行期间预留的内存不满足程序分配新对象需求，会出现一次并发失败，这时虚拟机不得不启动后备方案：Serial Old 收集器进行老年代收集，这样停顿时间就很长了。 参数 `-XX:CMSInitiatingOccupancyFraction` 可以设置虚拟机启动时的预留内存大小（占比）。

- **产生内存碎片**：CMS 采用标记清除算法，可能会导致内存碎片，空间碎片过多时，会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但是无法找到足够大的内存空间来分配当前对象，而不得不触发一次 Full GC。为了解决这个问题，CMS 提供了 
  `-XX: +UseCMSCompactAtFullCollection` 开关参数，用于在 CMS 不得不 Full GC 时开启内存碎片的合并整理，内存整理时必须移动存活对象，是无法并发，这样空间碎片解决了，但是停顿时间会边长。

### 3.5.6 G1 回收器

它开创了收集器**面向局部收集**的设计思路和**基于 Region 的内存布局模式**。

G1 是一款主要面向服务端应用的垃圾收集器，JDK 9 发布，G1 宣告取代 Parallel Scavenge 和 Parallel Old 组合，成为服务端下默认的垃圾回收器，CMS 则沦为声明不推荐使用的回收器。

G1 之前的所有回收器，GC 的目标要么是整个新生代，要么是整个老年代，要么是整个堆，G1 脱离了这个机制，它可以面向堆内存任何部分来组成回收集（Collection Set，简称 `CSet`），垃圾回收的衡量标准**不再是它属于哪个分代**，而是**那块内存中存放的垃圾最多，回收收益最大**。这就是 G1 的 **Mixed GC** 模式。

G1 开创的**基于 Region 的堆内存布局是它能实现 可预测的停顿时间模型** 的关键。

虽然 G1 也是**遵循分代收集理论**设计，但是其堆内存的布局与其他收集器有十分明显的差异：

> G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演不同的角色（Eden、Survivor、Old、Humongous），收集器能够对不同角色的 Region 采用不同策略去处理。

Region 有一类特殊的 Humongous 区域，专门存储大对象，G1 认为只要大小**超过一个 Region 容量一半的对象**即可判定为大对象。
每个 Region 大小可通过参数 `-XX:G1HeapRegionSize` 设定，范围为1MB-32MB，且应为 2次幂。
对超过了整个 Region 的超大对象，会被存放在 N 个连续的 Humongous Region 中，G1 大多数都将 Humongous Region 作为老年代的一部分来看待。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504154629397.png" alt="image-20220504154629397" style="zoom:33%;" />

虽然 G1 仍保留新生代和老年代概念，但它们不再是固定了，它们都是一系列**区域的动态集合**。

> G1 之所以能建立**可预测的停顿时间**模型，是因为它将 Region 作为单次回收的最小单元，每次收集的内存空间都是 Region 的整数倍，这样可以有计划的避免整个 Java 堆中进行全区域的垃圾收集。
>
> 更具体的处理思路是让 G1 去跟踪各个 Region 中垃圾堆积的价值大小（价值即 回收所获得的空间空间大小以及回收所需空间的经验值），后台维护一个优先队列，每次根据用户设定允许的收集停顿时间（`-XX:MaxGCPauseMillis` 指定，默认 200ms），优先处理回收价值收益最大的 Region。

G1 的原理很简单，但是实现起来比较复杂，有以下几点关键细节问题需要处理：

- 将 Java 堆分成多个独立 Region，**跨 Region 引用对象如何解决**？之前解决跨带时通过记忆集，但是在 G1 上实现记忆集则非常复杂，它的每个 Region 都维护有自己的记忆集，这些记忆集会记录别的 Region 指向自己的指针，并标记这些指针分别来自哪些卡页的范围之内。

  G1 的记忆集在存储本质上是一种哈希表，Key 是别的 Region 的起始地址，Value 是一个集合，里面存储的元素是卡表的索引号。
  这种双向的卡表结构（卡表是 "我指向谁"，这种结构还记录了 "谁指向我"）比原来的卡表实现起来更复杂。

  同时 Region 数量比传统收集器的分代数量多得多，因此 G1 比其他传统垃圾收集器占更多的内存。

- **并发标记阶段如何保证收集线程和用户线程互不干扰运行**。

  这里首先要解决用户线程改变对象引用关系时，保证其不能打破原本的对象图结构（见上3.4.6 提到的 **并发的可达性分析**）。

  CMS 采用增量更新算法实现并发可达性分析，而 G1 是通过原始快照算法实现。

  另外，GC 对用户线程的影响还体现在 **回收过程中新建对象的内存分配**，程序要继续运行就肯定会持续有新对象创建。

  > G1 为每一个 Region 设计了两个名为 TAMS（Top at Mark Start）的指针，把 Region 中的一部分空间划分出来用于并发过程中的新对象分配，并发回收时新分配的对象地址必须在这两个指针位置上。G1 默认这个地址上的对象都是存活的，不纳入回收范围。

	与CMS 中 "Concurrent Mode Failure"失败会导致 Full GC 类似，如果内存回收速度赶不上内存分配速度，G1 也要被迫冻结用户线程执行，导致 Full GC。
	
- **如何建立可靠的停顿预测模型**：用户通过 `-XX:MaxGCPauseMills` 指定的停顿时间只意味着垃圾收集发生之前的**期望值**。G1 如何满足用户期望呢？G1 的停顿预测模型是以衰减均值为理论基础来实现的。

  > G1 会记录每个 Region 的回收耗时、每个 Region 记忆集中脏卡数量等各个可测量的步骤花费的成本，并分析出平均值、标准偏差、置信度等统计信息。
  >
  > 这里的衰减平均值是指**它会比普通的平均值更容易受新数据影响**，代表最近的平均状态。
  >
  > Region 中统计状态越新越能决定其回收价值。

G1 运作过程：

- **初始标记**：标记GC Roots 能直接关联的对象，并且修改 TAMS 指针的值，让下一阶段用户并发运行时能正确在可用 Region 中分配新对象，需要 STW。
- **并发标记**：从 GC Roots 开始对堆中对象进行可达性分析，扫描整个堆的对象图，找出要回收的对象，这阶段耗时长，可与用户程序并发执行，对象图扫描完成后还要重新处理 原始快照 记录下的在并发时有引用变动的对象。
- **最终标记**：STW，处理并发阶段结束后遗留的最后少量的 原始快照 记录。
- **筛选回收**：更新 Region 的统计数据，对各个 Region 的回收价值和成本排序，根据用户期望的停顿时间来指定回收计划，可以选择任意多个 Region 进行收集，将存活对象复制到空的 Region 中，清理整个旧 Region 的全部空间。这里涉及存活对象移动，必须暂停用户线程，多条收集器线程并行完成。

![image-20220504162045815](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504162045815.png)

G1 缺点：

- **内存负载高**：G1 的卡表实现复杂，且堆中每个 Region，无论是新生代还是老年代，都必须有一份卡表，导致 G1 的记忆集（和其他内存）可能会占整个堆的 20% 甚至更多。

- **实现复杂**：为了维护卡表，G1 和 CMS 都要用到写屏障，不过不同的是 CMS 单单用了写后屏障，而 G1 除了用写后屏障来进行同样的卡表维护，为了实现原始快照，还要用写前屏障来跟踪并发时指针变化情况。

  由于 G1 对写屏障的操作复杂，CMS 处理写屏障采用直接同步，而 G1 处理写屏障不得不将其实现为类似于消息队列结构，把写前屏障和写后屏障中要做的事都放在队列中，然后异步处理。

## 3.6 低延迟垃圾收集器

衡量垃圾收集器的三项重要指标：**内存占用、吞吐量和延迟**。

三者构成一个不可能三角，想要 3 个方面同时表现完美的收集器是很困难的，一款优秀的收集器通常最多可以同时达成其中两项。

随着硬件的发展，我们越来越能容忍机器硬件多占用一点内存了，硬件的性能越高，吞吐量会更高，但对延迟不一定如此，如对 1TB 的堆进行垃圾收集速度肯定不如 1GB 堆进行垃圾收集快。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504171635432.png" alt="image-20220504171635432" style="zoom:33%;" />

浅色表示用户线程挂起，深色表示可以并发运行。

Shenandoah 和 ZGC 几乎整个工作过程都是并发的，只有初始标记、最终标记会有短暂的停顿。

Shenandoah 和 ZGC 都是低延迟垃圾收集器。

### 3.6.1 Shenandoah 收集器

Shenandoah 是 Red Hat 公司独立开发的收集器，Oracle JDK 不支持，Open JDK 支持。

从代码历史渊源来看，比起 ZGC，Shenandoah 更像 G1 的继承者，它们**有着相似的堆内存布局，在初始标记、并发标记**等许多阶段的处理思路上都高度一致。

Shenandoah 相比 G1 又有什么改进呢？虽然 Shenandoah 也是基于 Region 的堆内存布局，同样有用于存大对象的 Humongous Region，默认的回收策略也是优先处理回收价值大的 Region。但在管理堆内存方便，它与 G1 至少有 3 个明显的不同之处，最重要的是支持**并发的整理算法**，其次，Shenandoah **默认不使用分代收集**，不会有专门的新生代 Region 或者老年代 Region cunzai1；最后 Shenandoah 摒弃了 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为 "**连接矩阵**"的全局数据结构来记录跨 Region 的引用关系，降低了处理跨带指针时的记忆集维护消耗。

> 连接矩阵可以简单理解为一张二维表格，如果 Region N 有对象指向 Region M，就在表格的 N 行 M 列打上一个标记。
>
> 回收时通过连接矩阵就可以得知哪些 Region 之间产生了跨带引用。

Shenandoah 收集器工作过程大致可以划分为如下 9 个阶段：

- **初始标记**：与 G1 相同，首先标记与 GC Roots 直接关联的对象，这个阶段仍需 STW，停顿时间与 GC Roots 数量有关
- **并发标记**：与 G1 相同，遍历对象图，标记全部可达对象，与用户线程并发。
- **最终标记**：与 G1 相同，处理剩余的 原始快照 扫描，并在这个阶段统计出回收价值最高的 Region，将这些 Region 构成一组回收集，最终标记也会有小段的 STW。
- **并发清理**：清理整个区域内连一个存活对象都没有的 Region
- **并发回收**：**是 Shenandoah 与之前的 `HotSpot` 之前其他收集器的核心差异**。这个阶段 Shenandoah 要把回收集中的存活对象先复制一份到其他未被使用的 Region 之中。如果 STW 那么好处理，但是要与用户线程并发，困难点在于移动对象同时，用户线程仍可能对被移动的对象进行读写访问，移动对象是一次性行为，但移动之后整个内存中所有指向该对象的引用都是旧对象的地址，这很难一瞬间全修改，Shenandoah 通过**读屏障和称为 "Brooks Pointers" 的转发指针**解决。这个阶段时间长短取决于回收集大小。
- **初始引用更新**：并发回收阶段结束后，需要将堆中所有指向就对象的引用修正到复制后的新地址，这个操作称为**引用更新**。引用更新的初始化阶段实际上没有做什么具体的处理，设立这个阶段只是为了**建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务**。会产生短 STW。
- **并发引用更新**：真正开始进行引用更新操作，与用户线程并发，长度取决于内存中涉及的引用数量的多少。它不需要沿着对象图搜索，只要按照内存物理地址顺序，线性搜索出引用类型，把旧值改为新值即可。
- **最终引用更新**：解决堆中引用更新后，还要修正存在于 GC Roots 中的引用。这个阶段是 Shenandoah 的最后一次 STW。
- **并发清理**：此时整个回收集中所有 Region 已无存活对象，这些 Region 都变成全是垃圾的 Region，最后调用一次并发清理过程来回收这些 Region 空间。

![image-20220505153224816](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220505153224816.png)

#### Brooks Pointer

之前在实现对象移动与用户线程并发时的一种解决方案是在被移动对象原有内存上设置**保护陷阱**，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，进入预先设好的异常处理，再将其中的代码逻辑把访问转发到复制后的新对象。虽然能实现对象移动和用户线程并发，但如果没有 OS 的支持，这种方案将导致用户态频繁切换到核心态，代价很大，不能频繁使用。

Brooks 提出可以在原有对象布局的最前面统一增加一个新的引用字段，在正常不处于并发移动情况下，该引用指向对象自己。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220505154049668.png" alt="image-20220505154049668" style="zoom: 25%;" />

有了转发指针后，所有间接对象访问技术的缺点都是相同的：**每次对象访问会带来一次额外转向开销**。

但是转发指针至少比 保护陷阱强多了，只要旧对象内存没有被清理，虚拟机内存中所有通过旧引用地址访问的代码仍可用，都会转发到新对象继续工作。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220505155700529.png" alt="image-20220505155700529" style="zoom:25%;" />

需要注意，Brooks 形式的转发指针在设计上决定它是必然出现多线程竞争问题，如果收集器线程与用户线程发生的只是并发读取，无论读到旧对象还是新对象的字段，返回的结果都应该是一样的；但如果是并发写，就一定必须保证写操作只能发生在新复制的对象上，而不是写入旧对象的内存中。假设下列三件事并发执行：

1. 收集器线程复制了新的对象副本。
2. 用户线程更新对象某个字段
3. 收集器线程更新转发指针

如果不做保护措施，让 2 在 1、3之间发生，导致的结果就是用户线程对对象的变更失效，所以转发指针必须采取同步操作，让收集器线程或者用户线程对转发指针的访问只有其中之一能成功，另一个必须等待，避免两者交替。Shenandoah 通过CAS 保证并发时对象访问的正确性。

转发指针另一点需要注意：**执行频率**

尽管通过对象头的转发指针保证并发时源对象与复制对象的访问一致。从原理来看并不复杂，但 "**对象访问**" 是一个非常广的概念，对象读取、写入、比较、哈希计算、加锁等，都属于对象访问，要覆盖全部对象访问，那么 Shenandoah 必须同时设置读、写屏障去拦截。

之前介绍的卡表用写屏障是用来维护卡表，写屏障在 Shenandoah 也会使用，除此之外，为了实现转发指针，Shenandoah 在读、写屏障中都加入了额外的转发处理，尤其是读屏障代价，比写屏障更大。

代码中读操作出现的频率远大于写操作，读屏障数量也比写屏障多得多，所以读屏障使用必须谨慎，不允许任何重量级操作。

### 3.6.2 ZGC 收集器

是一款在 JDK11 中新增的低延迟垃圾收集器。

ZGC 是一块基于 Region 内存布局的，不设分代的，使用了**读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法的，以低延迟为首要目标**的一款垃圾收集器。

#### 内存布局

与 G1 一样，也采用 Region 的堆内存布局，但不同的是，ZGC 的 Region 具有动态性——**动态创建和销毁**，以及**动态的区域容量大小**。
在 x86 硬件平台下，ZGC 的 Region 可以具有以下大、中、小三类容量：

- 小型 Region：容量固定为 2MB，存放小于 256KB 的对象。

- 中型 Region：容量固定为 32MB，存放大于等于 256KB 但小于 4MB 的对象。

- 大型 Region：容量不固定，可以动态变化，但必须为 2MB 的整数倍，用以放置 4MB 及以上的大对象。

  每个 大型 Region 只会存放一个大对象，大型 Region 大小可能小于中型 Region。

  大型 Region 在 ZGC 的实现中是不会被重分配（重分配是 ZGC 的一种处理动作，用于复制对象的收集器阶段）的，因为复制一个大对象十分昂贵。

如下图：

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504211055845.png" alt="image-20220504211055845" style="zoom:33%;" />

#### 并发整理算法的实现

ZGC 使用了**读屏障**，但与 Shenandoah 不同的是 ZGC 使用更加复杂精巧的解题思路。

ZGC 收集器有一个标志性的设计是它采用的**染色指针技术**。

从前，如果我们要在对象上存储一些额外的、只供收集器或者 JVM 本身使用的数据，通常会在对象头中增加额外的存储字段，如对象的哈希值、分代年龄、锁记录就是这样存储的。

这种记录方式在有对象访问的情况下是很自然的，不会有额外负担，但是当对象存在被移动过的可能性，即不能保证对象访问成功，或者有一些根本就不会去访问对象，但又希望得到对象的某些信息的场景下。能不能从指针或者与对象无关的地方获取这些信息，比如是否能看出来对象被移动过？

这样的要求并非不合理的刁难，先不谈并发移动对象可能带来的可访问性问题，之前（3.4.6节）就介绍了可以在对象标记的过程中给对象打上三色标记，这些标记本质上**和对象引用有关，与对象本身无关**。

ZGC 的染色指针就是解决这类问题的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析时遍历对象图来标记对象，不如说遍历**引用图**来标记**引用**了。

> Serial 收集器通过标记在对象头处理，G1、Shenandoah 通过 `BitMap`（位图） 数据结构来记录标记信息。

#### 染色指针

直接将少量额外的信息存储在指针上的技术。

如今 64 位硬件能支持的最大物理地址空间为 256TB，64 位的 Linux 分别支持 47位的进程虚拟地址空间和46位的物理地址空间。

Linux 下 64 位指针的高18 位不能用来寻址，但剩余的 46 位指针能支持的 64TB 在今天仍是绰绰有余的。所以 ZGC 盯上了这剩下的 46 位指针宽度，**将高 4 位 提取出来存储 4 个标志信息**。

通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入重分配集（被移动过）、只能通过 `finalize()` 方法才能被访问到。当然，由于被阉割了 4 位，导致 ZGC 能管理的内存不可以超过 4TB。

![image-20220504214508188](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504214508188.png)

虽然染色指针有 4TB 的内存限制，不能支持 32 位平台，不能支持压缩指针等诸多约束，但其带来的收益是客观的，如下：

- 可以使一旦某个 Region 的**存活对象被移动走后，这个 Region 就可以立刻被释放和重用**，不用等待整个堆中所有指向该 Region 的引用被修正后才能被清理，使得理论上只要还有一个空闲的 Region，ZGC 就能完成收集。
- **染色指针可以大幅减少在 GC 时内存屏障的使用数量**，设置内存屏障的目的就是为了记录对象引用变动情况，通过设置染色指针，就可以省去一些专门的记录操作。实际上 ZGC 目前为止都没有使用写屏障，只使用了读屏障。
- 可以作为一种可扩展的存储结构，用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

#### x86 下的问题

JVM 作为一个普通进程，凭什么随意定义内存中某些指针的其中几位，OS 支持吗？

很遗憾，在 x86-64 平台并不支持，ZGC 的设计者只能采取其他补救措施了。

为了解决早期 x86 计算机系统不同进程之间的内存无法隔离的问题，Intel 80386 后来提供了 "保护模式" 用于隔离进程。

> 保护模式下，386 的 全部 32 条地址寻址线都有效，进程可访问最高可达 4GB 的内存空间，但此时不同于之前的物理内存寻址，处理器会使用 **分页管理机制** 将线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块称为页。
>
> 通过在线性虚拟空间和物理地址空间的页建立映射表，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址空间到物理地址空间的转换。

在 Linux/x86-64 平台上 ZGC 使用了**多重映射**，将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种**多对一**的映射，意味着 ZGC 在虚拟内存中看到的地址空间要比实际的堆内存容量来的更大。将染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换，就可以使用染色指针寻址了。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504220811427.png" alt="image-20220504220811427" style="zoom: 67%;" />

#### 工作流程

![image-20220504221406405](C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220504221406405.png)

- **并发标记**：与 G1 一样，遍历对象图做可达性分析，前后要经过类似 G1 的初始标记、最终标记的短暂停顿，而且这些停顿所做的事情在目标上也类似。与 G1 不同的是，ZGC 的标记是在指针上，而不是在对象上进行。
- **并发预备重分配**：这个阶段需要根据特定的查询条件统计出本次收集要清理哪些 Region，将这些 Region 组成重分配表。重分配集与 G1 收集器的回收集有区别，ZGC 划分 Region 的目的不同于 G1 做收益优先的增量回收。相反，ZGC 重分配集只是决定里面的存活对象会被重新复制到其他 Region 中，里面的 Region 会被释放，而不能说回收行为就只是针对这个集合中的 Region 进行，因为标记过程是针对全堆的。
- **并发重分配**：核心阶段，要**把重分配集的存活对象复制到新 Region 上，并为重分配中的每个 Region 维护一个转发表，记录从旧对象到新对象的转向关系**。得益于 染色指针 ，可以快速判断一个对象是否在重分配集中（被重分配后，指针的重分配标志位变化），当用户线程并发访问位于重分配集合中的对象时，会被内存屏障截获，根据转发表转发到新复制的对象，并修正更新该引用的值，使其直接指向新对象，这种行为也叫 "**自愈**"。
- **并发重映射**：**修正整个堆中指向重分配集中旧对象的所有引用**（因为重分配集中的对象 "搬家了"），但重映射不用急着完成，因为即使是旧引用也是可以自愈的，最多第一次使用时多一次转发和修正操作。这个阶段清理旧引用的主要目的是为了不变慢，所以说不是很迫切。

#### 缺点

它能承受的对象分配速率不会太高。

假设 ZGC 要对一个很大的堆做垃圾回收，能并发清除时间要持续十分钟，在这 10 分钟内，如果分配了大量的新对象，这些对象很难进入当次收集的标记范围，通常只能作为存活对象看待——尽管大部分对象朝生夕死。这就产生了大量浮动垃圾。

如果高速分配持续维持，每次完整的并发收集周期就会很长，回收到的内存空间持续小于并发产生的浮动垃圾所占的空间，堆中剩余空闲空间越来越小。

目前唯一的办法就是尽可能增加堆大小。但是要从根本上解决的话，还是需要引入分代收集，让新生对象都在一个专门的区域中出生，然后针对这个区域进行更频繁，更快的收集（新生代）。

# 第7章. 虚拟机类记载机制

## 7.2 类加载的时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载、验证、准备、解析、初始化、使用和卸载**。

其中**验证、准备、解析**三个部分统称为连接。

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220428230851356.png" alt="image-20220428230851356" style="zoom:67%;" />

这里的顺序是确定的，类加载过程必须按照这种顺序开始，而解析阶段不一定，它在某些情况下可以在初始阶段之后开始，这是为了支持Java的晚绑定特性。

**初始化情况**：

1. 遇到 new、`getstatic`、`putstatic` 或者 `invokestatic` 这四条字节码指令时，如果类没有进行过初始化，需要触发其初始化阶段，能够生成这四条指令的典型 Java 代码场景有：
   - 使用 new 关键字实例化对象
   - 读取或设置一个类的静态字段（常量除外）。
   - 调用一个类型的静态方法时。
2. 使用反射对类进行调用时，如果没有初始化那么初始化类。
3. 当初始化类时如果发现其父类没有初始化，那么先初始化父类。
4. 虚拟机启动时，用户要先初始化执行的主类（main() 方法的类）。

被动引用的例子之一：

```java
public class SuperClass {
    static {
        System.out.println("SupperClass init");
    }
    
    public static int value = 123;
}

public class SubClass entends SuperClass {
    static {
        System.out.println("SubClass init");
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
} 
```

控制台输出：

```
SupperClass init
123
```

注意这里只会造成父类的初始化，而不是子类的初始化。

> 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类初始化不会触发子类初始化。
>
> 至于是否要触发子类的加载和验证，这点在 Java 虚拟机规范中没有明确规定，这点取决于虚拟机的具体实现。
>
> 对于 ``HotSpot`` 来说可以通过 `-XX:+TraceClassLoading` 参数来让子类加载

被动引用例子2：

```java
public static NotInitialization{
    public static void main(String[] args) {
        SuperClass[] sca = new SupperClass[10];
    }
}
```

这类并没有触发类 `SuperClass` 的初始化，但这段代码触发了另一个类的初始化， `Lorg.***.SuperClass` 其中 `***` 是 `SuperClass` 对应的包。这个类是由虚拟机自动生成、直接继承于 `java.lang.Object` 的子类，创建动作由字节码指令 `newarray` 触发。

这个类代表一个元素类型为 `***.SuperClass` 的一维数组，数组中应用的属性和方法（length 属性和 clone 方法）都实现在这个类中。Java 语言对数组的访问很大程度上比 C/C++ 安全就是因为这个类包装了数组元素的访问，如果超出范围，那么报出异常。

被动引用例子3：

```java
public class ConstClass {
    static {
        System.out.println("ConstClass init");
    }
    
    public static final String HELLOWORLD = "hello world";
}

public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

这里也不会打印 `hello world`，因为这是对常量的引用，在编译阶段通过常量传播优化，已经将这个常量直接存储在`NotInitialization` 的常量池中，以后 `NotInitialization` 对常量的引用，转化为 `NotInitialization` 对自身常量池的引用。
也就是说这两个类的 Class 文件之中没有 `ConstClass` 类的符号引用入口，这两个类在编译成 Class 文件后就不存在任何联系了。

**接口**的加载过程和类加载过程稍有不同，针对**接口**需要说明一下：

> 接口也有初始化过程，在接口中不能使用 static{} 静态代码块，但编译器仍然会为接口生成 "<clinit>()" 类构造器，用于初始化接口中定义的成员变量。（在接口的成员变量统一为静态变量）
>
> 接口和类真正有区别的在前面初始化的第三种：当一个类初始化时，要求其父类全部初始化过了。
>
> 但是一个接口初始化时，不要求其父接口全部初始化，只有在真正使用到父接口时（如引用接口中定义的变量）才会初始化。

## 7.3 类加载过程

### 7.3.1 加载

加载阶段是整个类加载过程中的一个阶段，在加载过程，JVM 需要完成以下三件式：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。
- 将内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据访问入口。

而Java虚拟机规范对这三点要求不是很具体，例如**通过类的全限定名来获取此类的二进制字节流**，没有指定二进制字节流必须从某个 Class 文件获取，由此诞生了许多获取方式：

- 从 ZIP 压缩包读取，最终成为日后 JAR、EAR、WAR 格式的基础
- 从网络中获取，最典型的就是 Web Applet
- 从运行时计算生成，应用有动态代理技术。
- 从其他文件生成，JSP 技术。

相对于类加载过程的其他阶段，非数组类型的加载阶段是可控性最强的阶段。这个阶段既可以使用 Java 虚拟机内置的引导类加载器来完成，也可以由用户自定义的类加载器完成，程序员可以重写一个类加载的 `findClass()` 或者 `loadClass()` 方法定义自己的类加载器。

对于数组类而言，情况不同，数组类本身不通过类加载器创建，它是由 JVM 在内存中动态构造出来的，但数组类的元素类型（去掉所有维度）还是需要类加载完成，一个数组类创建过程遵循以下规则：

- 如果数组的组件类型（去掉一个维度的类型）是引用类型，那就递归采用本节定义的类加载方式来完成加载，数组将被标识在加载该组件类型的类加载器的类名称空间上。
- 如果数组的组件类型不是引用类型（例如int[] 数组的组件类型为 int），JVM 会将数组标记为与引导类加载器关联。
- 数组类的可访问性和它的组件类型的可访问性一直，如果组件类型不是引用类型，那么数组类的可访问默认为 public。

加载结束后，JVM 外部的二进制字节流按照虚拟机设定的格式存储在方法区中，方法区中的数据存储格式完全由虚拟机自行定义。

类型数据妥善安置在方法区后，会在 Java 堆中实例化一个 `java.lang.Class` 类对象，这个对象作为方法区中类型数据的外部接口。

### 7.3.2 验证（连接阶段的第一步）

目的是确保 Class 文件中包含的信息符合 Java 虚拟机规范的全部约束要求。

1. 文件格式验证

   要求字节流符合 Class 文件格式的规范，能被虚拟机处理。

   - 是否以魔数 `0xCAFEBABE` 开头
   - 主次版本号是否在当前 JVM 接受范围之内。
   - 常量池的常量是否有不被支持的常量类型。
   - 等等等

2. 元数据验证

   对字节码描述的信息进行语义分析，保证其信息符合 Java 语言规范

   - 这个类是否有父类（除了 Object 类，所有的类都应该有父类）
   - 这个类的父类是否继承了 final 类
   - 如果这个类不是抽象类，是否实现了父类或接口中要求实现的所有方法。
   - 类中的字段、方法是否与父类矛盾（；如覆盖父类的 final 字段，出现不符合规则的方法重载，例如方法参数都一致，返回值类型却不同等）。
   - ......

3. 字节码验证

   通过数据流分析和控制流分析，确定程序语义合法。

   - 保证任意时刻操作数栈的数据类型和指令代码序列都能配合工作，不会出现类似于"在操作数栈放置一个 int 类型的数据，使用时却按照 long 类型来加载入本地变量表中" 这样的情况。
   - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
   - ......

4. 符号引用验证

   发生在虚拟机将符号引用转化为直接引用的时候（也就是解析阶段中发生的事）。

   可以看作是对类自身以外的各类信息进行匹配性校验，通俗来说就是该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 指定类中是否存在符合方法的字段描述符及简单名称描述的方法和字段。
   - 符号引用中类、字段、方法的可访问性。

### 7.3.3 准备（连接阶段的第二步）

正是为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段。这些变量使用的内存都在方法区中分配，JDK 7以前，`HotSpot` 使用永久代实现方法区时，完全符合这种逻辑。JDK 8及以后，类变量会随着 Class 对象一起放在 Java 堆中，这时类变量在方法区就是一种逻辑的表达了。

在准备阶段，内存中仅仅分配类变量，不包括实例变量，假设一个类变量定义为：

```java
public static int value = 123;
```

变量 value 在准备阶段后的初始值是 0 而不是 123，将 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器 `<clinit>()` 方法中，所以将 value 赋值为 123 的动作要在类初始化阶段才会被执行。

### 7.3.4 解析（连接阶段的第三步）

将常量池的符号引用转换为直接引用的过程。

- 符号引用：用一组符号来描述所引用的目标，符号可以是任何形式的字面量。
- 直接引用：可以是直接指向目标的指针、相对偏移量、一个能间接定位到目标的句柄。

### 7.3.5 初始化

是类加载过程的最后一步。

初始化阶段会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源，初始化阶段其实就是执行 `<clinit>()` 方法，`<clinit>()` 方法不是程序员在 Java 中编写的方法，是 `javac` 的自动生成物。

- `<clinit>()` 方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，熟序是由语句在源文件中出现的顺序决定，在前面的静态语句块可以赋值，但是不可以访问，如下：

  ```java
  public static Test {
      static {
          i = 0; // 可以正常编译
          System.out.println(i);  // 编译器会提示“非法向前引用”
      }
      static int i = 1;
  }
  ```

- `<clinit>()` 方法与类的构造函数（即 `<init>()` 方法）不同，它不需要显式调用父类构造器，JVM 会保证子类的 `<clinit>()` 方法执行前，父类 `<clinit>()` 方法执行

- 由于父类 `<clinit>()` 方法先执行，也就意味着父类中定义的静态句块要优于子类的变量赋值操作。
- `<clinit>()` 方法对于类或者接口来说不是必须的，如果一个类没有静态语句块，也没有对变量的复制操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。
- JVM 必须保证一个类的 `<clinit>()` 方法在多线程环境中被正确的加锁同步，如果多个线程去初始化一个类，那么只有一个线程去执行这个类的 `<clinit>()` 方法，其他线程需要阻塞等待这个线程执行完毕 `<clinit>()` 方法，如果一个类的 `<clinit>()` 方法有耗时很长的操作，可能造成多个线程阻塞。

## 7.4 类加载器

### 7.4.1 类与类加载器

类加载器只用于实现类的加载动作，对于任意一个类，必须由加载它的类加载器和这个类本身一起共同确立其在 JVM 中唯一性，每一个类加载器都拥有一个独立的类名称空间。

> 比较两个类是否相等，只有这两个类由同一个类加载器加载的前提下才有意义，否则即使两个类来自同一个 Class 文件，被同一个 JVM 加载，只要加载的类加载器不同，那么两个类必定不相等。
>
> 这里的相等，包括代表类的 Class 对象的 equals() 方法、`isAssignableFrom`() 方法，`isInstance()` 方法返回结果，包括使用 `instanceof` 关键字做对象所属关系判定等各种情况。

不同的类加载器对 instanceof 关键字运算的结果的影响：

```java
public class TestClass{
    public static void main(String[] args) throws Exception{
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                return super.loadClass(name);
            }
        };
        Object s =  myLoader.loadClass("com.jvm.TestClass").newInstance();
        System.out.println(s instanceof TestClass);
        System.out.println(s.getClass());
    }
}
```

结果：

```
false
class com.jvm.TestClass
```

这个对象确实是类 `com.jvm.TestClass` 实例化出来的，但是这个对象与类 `com.jvm.TestClass` 做类型检查的时候返回了 false。

这是因为 JVM 中同时存在了两个 `TestClass` 类，一个由虚拟机的应用程序类记载器加载，一个由我们自定义的类加载器加载，虽然来自同一个 Class 文件，但是由于不同的类加载器，因此类型检查时结果仍然为 false。

### 7.4.2 双亲委派模型

站在 JVM 角度下，只存在两种不同的类加载器：一种是启动类加载器，用 C++ 实现，是虚拟机的一部分，另外就是其他的类加载器，由 Java 实现的，独立存在与 JVM 外部，全部继承自抽象类：`java.lang.ClassLoader`

从开发人员角度，类加载器划分的应该更细一点：

- **启动类加载器**：能够加载 lib 目录下的类，如rt.jar、tools.jar 等，无法被 Java 程序直接引用，用户在编写自定义类加载器时如果把加载请求委派给引导类加载器去处理，那直接使用 null 替代即可，如下代码段：

  > `Class.getClassLoader()` 方法的代码片段

  ```java
  public ClassLoader getClassLoader() {
      ClassLoader cl = getClassLoader0();
      if (cl == null)
          return null;
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) {
          ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
      }
      return cl;
  }
  ```

- **扩展类加载器**：以 Java 代码实现，在`sun.misc.Launcher$ExtClassLoader`，负责加载被 `java.ext.dirs` 系统变量指定的路径中的所有类库。
  这是一种 Java 系统类库的扩展机制。

- **应用程序类加载器**：这个类加载器由 `sun.misc.Launcher$AppClassLoader` 来实现。应用程序加载器是 `ClassLoader` 类中的 `getSystemClassLoader()` 方法的返回值，所以也称为系统加载器，它负责加载用户类路径伤所有的类库，开发者可以直接在代码中使用这个类加载器。
  **如果 APP 中没有定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。**

<img src="C:\Users\HASEE\Desktop\读书笔记\深入理解Java虚拟机第三版.assets\image-20220430231923293.png" alt="image-20220430231923293" style="zoom:33%;" />

上图显示的加载器之间的层次关系被称为类加载器的 "双亲委派模型"。双亲委派要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

这里的类加载器之间的父子关系一般不是以**继承**的关系来实现的，而是通常使用**组合**关系来复用父加载器的代码。

> 类加载器工作过程：如果一个类加载器收到类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器去完成。直到该加载器没有父类加载器，则尝试自己加载，如果自己无法加载，则让子类加载器处理。

**好处**：

- Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 `java.lang.Object`，它存放于 `rt.jar` 中，无论哪一个类加载器要加载这个类，最终都会委派给最顶端的启动类加载器加载，因此 Object 类在程序的各种类加载器去加载都能保证是同一个类。反之，如果由各个类加载器自行去加载，如果用户自己编写一个名为 `java.lang.Object` 的类，并放在程序的 `ClassPath` 中，系统中就会出现多个不同的 Object 类，应用程序会一片混乱。
  `如果用户自己去写一个与 rt.jar 类库中已有类重命名的 java 类，会发现它可以正常编译，但永远无法被加载运行。`

- 实现简单，实现双亲委派的代码很短：

  ```java
  protected Class<?> loadClass(String name, boolean resolve)
      throws ClassNotFoundException
  {
      synchronized (getClassLoadingLock(name)) {
          // 首先检查请求加载的类是否已经被加载过了
          Class<?> c = findLoadedClass(name);
          
          if (c == null) {
              long t0 = System.nanoTime();
              try {
                  if (parent != null) {
                      // 让父类加载
                      c = parent.loadClass(name, false);
                  } else {
                      // 是启动类加载器，没有父类加载器，自己加载
                      c = findBootstrapClassOrNull(name);
                  }
              } catch (ClassNotFoundException e) {
                  // 如果父类加载器抛出 ClassNotFoundException
                  // 说明父类加载器无法完成加载请求
              }
              if (c == null) {
                  // 父类加载器无法加载
                  // 调用自身的 findClass 完成加载请求
                  long t1 = System.nanoTime();
                  c = findClass(name);
                  // this is the defining class loader; record the stats
                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                  sun.misc.PerfCounter.getFindClasses().increment();
              }
          }
          if (resolve) {
              resolveClass(c);
          }
          return c;
      }
  }
  ```
  

### 7.4.3 破坏双亲委派模型

Java 历史上有三次较大规模的破坏双亲委派模型的情况：

- **双亲委派模型出现之前（JDK1.2 以前）**：类加载器在 JDK1.0 就已经存在，为了兼容用户自定义的类加载器代码，Java 设计者引入双亲委派时不得不作出妥协：在 JDK1.2 后的 `java.lang.ClassLoader` 中添加一个新的 protected 方法 `findClass()`，并引导用户编写的类加载逻辑时尽可能去重写这个方法。按照 `loadClass()` 的逻辑，如果父类加载失败，会使用自己的 `findClass()` 方法完成加载，这样既不影响用户按自己的意愿加载类，也可以保证信息出来的类加载器符合双亲委派规则。

- **这个模型自身的缺陷导致**：双亲委派可以解决各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的类加载器加载），如果有基础类型要调用用户的代码该怎么办呢？

  例如 JNDI 服务，这是 Java 的一个标准服务，JDK1.3 时已经加入到 rt.jar 中，它需要调用其他厂商实现并部署在应用程序的 `ClassPath` 下的 JNDI 服务的代码，可问题是启动类加载器不可能认识类路径下的代码（应用程序类加载器负责加载），怎么办？

  Java 设计团队引入一个设计：线程上下文类加载器（`Thread Context ClassLoader`）这个类加载器可以通过`Thread` 类的 `setContextClassLoader()` 方法进行设置

  ```java
  public void setContextClassLoader(ClassLoader cl) {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) {
          // 如果创建线程时还未设置，他会从父线程中继承一个
          // 如果应用程序全局范围都没有设置过，这个类加载器默认就是应用程序类加载器
          sm.checkPermission(new RuntimePermission("setContextClassLoader"));
      }
      contextClassLoader = cl;
  }
  ```

  JNDI 服务使用这个线程上下文类加载器去加载所需的服务代码，这是一种父类加载器请求子类加载器完成类加载的行为，实际上是打通的双亲委派的层次结构来逆向使用类加载器。

- **用户对程序的动态性追求导致**：代码热交换（Hot Swap）、模块热部署（Hot Deployment）等，希望 Java APP 像外设一样，不用重启机器就能立即使用。

  IBM 公司的 `OSGi` 就可以通过类加载器实现热部署，每一个程序模块（以下称为 Bundle）都有自己的一个类加载器，需要更换一个 Buddle 时，会将类加载器连同 Buddle 一起换掉实现热交换。收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

  - 将 java.* 开头的类委派给父类加载器加载。
  - 否则将委派列表名单中的类委派给父类加载器加载。
  - 否则将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载
  - 否则查找 Bundle 的 `ClassPath`，使用自己的类加载器加载。
  - 否则查找类是否在自己的 `Fragment Bundle` 中，如果在，则委派给`Fragment Bundle` 的类加载器加载
  - 否则查找 `Dynamic Import` 列表的 Bundle，委派给对应 Bundle 的类加载器加载
  - 否则类查找失败